<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>La Choucroute — Radio</title>

    <link rel="stylesheet" href="public/style.css">
    <link rel="stylesheet" href="public/fonts.css">
    <link rel="stylesheet" href="public/dist.css">
</head>

<body>
    <main>
        <h1 class="body-18 uppercase abcFont-bold">Choucroute Radio</h1>

        <div class="player">
            <a id="playBtn" href="#" role="button" class="body-16 text-center uppercase abcFont-bold mg-b-8">Play</a>

            <div><img src="public/source/img/cd-rom.png" alt=""></div>

            <div>
                <p id="trackTitle" class="body-16 text-center uppercase abcFont-bold">—</p>
            </div>
        </div>

        <div>
            <p class="body-16 text-center uppercase abcFont-bold" id="paris-time"> Tuesday, February 11, <br> Paris,
                20:30:58</p>
        </div>

        <!-- Audio stream -->
        <audio id="audio" preload="metadata" crossorigin="anonymous" playsinline>
            <source src="https://radio.choucroute.club/live.mp3" type="audio/mpeg">
        </audio>
    </main>

    <script>
        function updateParisTime() {
            const options = {
                weekday: 'long', year: 'numeric', month: 'long', day: 'numeric',
                hour: '2-digit', minute: '2-digit', second: '2-digit',
                timeZone: 'Europe/Paris'
            };
            const parisTime = new Date().toLocaleDateString('en-US', options);
            document.getElementById('paris-time').textContent = parisTime + ', Paris';
        }

        updateParisTime();
        setInterval(updateParisTime, 1000);

        const audio = document.getElementById("audio");
        const playBtn = document.getElementById("playBtn");
        const trackTitle = document.getElementById("trackTitle");

        const META_URL = "https://radio.choucroute.club/status-json.xsl";

        function fixMojibake(s) {
            if (!s || !/[ÃÂ]/.test(s)) return s;
            try {
                const bytes = Uint8Array.from([...s].map(c => c.charCodeAt(0)));
                return new TextDecoder("utf-8").decode(bytes);
            } catch {
                return s;
            }
        }

        function setButton(state) {
            switch (state) {
                case "loading":
                    playBtn.textContent = "Loading…";
                    playBtn.style.opacity = "0.6";
                    break;
                case "playing":
                    playBtn.textContent = "Pause";
                    playBtn.style.opacity = "1";
                    break;
                case "paused":
                default:
                    playBtn.textContent = "Play";
                    playBtn.style.opacity = "1";
            }
        }


        setButton("paused");

        // ✅ Warmup
        let warmed = false;
        function warmUp() {
            if (warmed) return;
            warmed = true;

            audio.muted = true;
            const p = audio.play();
            if (p && typeof p.then === "function") {
                p.then(() => {
                    audio.pause();
                    audio.currentTime = 0;
                    audio.muted = false;
                }).catch(() => {
                    audio.muted = false;
                });
            } else {
                audio.muted = false;
            }
        }
        document.addEventListener("pointerdown", warmUp, { once: true });
        document.addEventListener("keydown", warmUp, { once: true });

        /* =========================
           ✅ AUTO-RECONNECT LOGIC
        ========================== */
        let shouldBePlaying = false;
        let retryTimer = null;

        function tryPlay(delayMs = 300) {
            clearTimeout(retryTimer);
            retryTimer = setTimeout(async () => {
                if (!shouldBePlaying) return;

                try {
                    await audio.play();
                    // si ça marche, l'event "playing" mettra le bouton à jour
                } catch (e) {
                    // réessaie (stream en train de se reconnecter côté Icecast)
                    tryPlay(800);
                }
            }, delayMs);
        }

        playBtn.addEventListener("pointerup", (e) => {
            e.preventDefault();
            e.stopPropagation();

            // toggle intention
            shouldBePlaying = audio.paused; // si c'est paused -> on veut jouer, sinon on veut arrêter

            if (!shouldBePlaying) {
                audio.pause();
                return;
            }

            setButton("loading");
            tryPlay(50); // très rapide, réduit le "lag" ressenti
        });

        /* ===== Audio events ===== */
        audio.addEventListener("playing", () => setButton("playing"));

        audio.addEventListener("pause", () => {
            if (!shouldBePlaying) setButton("paused");
        });

        audio.addEventListener("waiting", () => {
            if (shouldBePlaying) setButton("loading");
        });

        audio.addEventListener("stalled", () => {
            if (shouldBePlaying) {
                setButton("loading");
                tryPlay(500);
            }
        });

        audio.addEventListener("ended", () => {
            if (shouldBePlaying) {
                setButton("loading");
                tryPlay(500);
            }
        });

        audio.addEventListener("error", () => {
            if (shouldBePlaying) {
                setButton("loading");
                tryPlay(800);
            } else {
                setButton("paused");
            }
        });

        /* ===== Metadata ===== */
        function pickSource(icestats) {
            const s = icestats?.source;
            if (!s) return null;
            return Array.isArray(s) ? s[0] : s;
        }

        async function loadTitle() {
            try {
                const res = await fetch(META_URL, { cache: "no-store" });
                const data = await res.json();
                const src = pickSource(data.icestats);
                if (!src?.title) return;
                trackTitle.textContent = fixMojibake(src.title);
            } catch { }
        }

        loadTitle();
        setInterval(loadTitle, 5000);
    </script>

</body>

</html>